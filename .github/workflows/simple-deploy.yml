name: Simple Deploy to Ubuntu VM

on:
  push:
    branches: [ "main" ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Build application
        run: |
          GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o go-db-demo ./web/cmd

      - name: Connect to Tailscale
        uses: tailscale/github-action@v2
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          tags: tag:ci

      - name: Check required secrets
        run: |
          set -euo pipefail
          missing=0
          for key in TS_HOST DEPLOY_SSH_KEY DB_USER DB_PASSWORD DB_NAME; do
            if [ -z "${{ secrets[format('{0}', key)] }}" ]; then
              echo "❌ ERROR: $key is missing"
              missing=1
            fi
          done
          if [ "$missing" -eq 1 ]; then
            echo "Add the missing secrets in your repo settings."
            exit 1
          fi
          echo "✅ All secrets present"

      - name: Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.TS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Test connectivity & copy artifacts
        run: |
          set -euo pipefail
          HOST="${{ secrets.TS_HOST }}"
          echo "Testing connectivity to $HOST..."
          if ! timeout 10 nc -zv "$HOST" 22 2>/dev/null; then
            echo "Cannot reach $HOST on port 22"
            exit 1
          fi
          echo "Port 22 reachable, copying artifacts..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 go-db-demo deploy@"$HOST":/tmp/go-db-demo-new
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 internal/db/migrations/*.up.sql deploy@"$HOST":/tmp/

      - name: Deploy on server
        run: |
          set -euo pipefail
          HOST="${{ secrets.TS_HOST }}"

          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy@"$HOST" bash -s << 'EOF'
          set -euo pipefail

          APP_DIR="$HOME/app"
          BIN_TMP="/tmp/go-db-demo-new"
          MIGS_GLOB="/tmp/*.up.sql"

          # Stop old process if running
          pkill -f go-db-demo || true
          sleep 1

          # App dir and binary
          mkdir -p "$APP_DIR"
          mv "$BIN_TMP" "$APP_DIR/go-db-demo"
          chmod +x "$APP_DIR/go-db-demo"

          # Write .env (values come from env exported by the caller – see next block)
          cat > "$APP_DIR/.env" <<ENVEOF
          SERVER_HOST=0.0.0.0
          SERVER_PORT=8080
          GIN_MODE=release
          DB_HOST=localhost
          DB_PORT=5432
          DB_USER=${DB_USER}
          DB_PASSWORD=${DB_PASSWORD}
          DB_NAME=${DB_NAME}
          DB_SSL_MODE=disable
          ENVEOF

          # === Database bootstrap (admin via OS postgres user) ===
          # Note: do not change superuser 'postgres' password; use it only for admin with sudo.
          echo "Bootstrapping database & role..."
          sudo -u postgres psql -v ON_ERROR_STOP=1 <<SQL
          DO $$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_database WHERE datname = '${DB_NAME}') THEN
              PERFORM dblink_exec('dbname=postgres', ''); -- ensure dblink ok if installed; harmless if absent
            END IF;
          END $$;
          SQL

          # Create DB if missing
          sudo -u postgres psql -v ON_ERROR_STOP=1 -tc "SELECT 1 FROM pg_database WHERE datname='${DB_NAME}'" | grep -q 1 || \
            sudo -u postgres createdb "${DB_NAME}"

          # Create role if missing (LOGIN role for app)
          sudo -u postgres psql -v ON_ERROR_STOP=1 -tc "SELECT 1 FROM pg_roles WHERE rolname='${DB_USER}'" | grep -q 1 || \
            sudo -u postgres psql -v ON_ERROR_STOP=1 -c "CREATE ROLE ${DB_USER} LOGIN PASSWORD '${DB_PASSWORD}';"

          # Ensure privileges
          sudo -u postgres psql -v ON_ERROR_STOP=1 -c "GRANT ALL PRIVILEGES ON DATABASE ${DB_NAME} TO ${DB_USER};"
          # Future objects in public schema
          sudo -u postgres psql -v ON_ERROR_STOP=1 -d "${DB_NAME}" -c "ALTER SCHEMA public OWNER TO ${DB_USER};"
          sudo -u postgres psql -v ON_ERROR_STOP=1 -d "${DB_NAME}" -c "GRANT ALL ON SCHEMA public TO ${DB_USER};"
          sudo -u postgres psql -v ON_ERROR_STOP=1 -d "${DB_NAME}" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ${DB_USER};"
          sudo -u postgres psql -v ON_ERROR_STOP=1 -d "${DB_NAME}" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ${DB_USER};"

          # === Run migrations as app role ===
          echo "Running migrations as ${DB_USER} on ${DB_NAME}..."
          shopt -s nullglob
          for f in ${MIGS_GLOB}; do
            echo "Applying: \$f"
            PGPASSWORD="${DB_PASSWORD}" psql -h localhost -U "${DB_USER}" -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f "\$f"
          done
          shopt -u nullglob

          # Start app
          cd "$APP_DIR"
          echo "Starting application..."
          nohup ./go-db-demo > app.log 2>&1 &
          echo \$! > app.pid
          sleep 2

          # Health check
          if curl -fsS http://localhost:8080/healthz > /dev/null; then
            echo "✅ Health check passed"
          else
            echo "❌ Health check failed. Recent logs:"
            tail -200 app.log || true
            exit 1
          fi
          EOF
        env:
          # Export DB secrets into the remote heredoc environment
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}

      - name: Verify deployment
        run: |
          set -euo pipefail
          HOST="${{ secrets.TS_HOST }}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy@"$HOST" 'curl -fsS http://localhost:8080/healthz && echo "Final verification: SUCCESS"'
