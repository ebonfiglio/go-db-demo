name: Deploy app

on:
  push:
    branches: ["develop", "main"]

jobs:
  # =========================
  # DEV (home server) — push to develop
  # =========================
  deploy_dev:
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Go setup
        uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Build (linux/amd64)
        run: GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o go-db-demo ./web/cmd

      - name: Connect to Tailscale
        uses: tailscale/github-action@v2
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          tags: tag:ci

      - name: Check secrets (dev)
        env:
          TS_HOST: ${{ secrets.TS_HOST }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
        run: |
          set -euo pipefail
          for var in TS_HOST DEPLOY_SSH_KEY DB_HOST DB_USER DB_PASSWORD DB_NAME; do
            if [ -z "${!var:-}" ]; then echo "Missing secret: $var"; exit 1; fi
          done

      - name: Setup SSH (dev)
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.TS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Copy artifacts (dev)
        run: |
          set -euo pipefail
          HOST="${{ secrets.TS_HOST }}"
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 go-db-demo deploy@"$HOST":/tmp/go-db-demo-new
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 internal/db/migrations/*.up.sql deploy@"$HOST":/tmp/

      - name: Deploy on server (dev)
        run: |
          set -euo pipefail
          HOST="${{ secrets.TS_HOST }}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy@"$HOST" \
          DB_HOST="${DB_HOST}" DB_USER="${DB_USER}" DB_PASSWORD="${DB_PASSWORD}" DB_NAME="${DB_NAME}" 'bash -s' << "EOF"
          set -euo pipefail

          APP_DIR="$HOME/app"
          BIN_TMP="/tmp/go-db-demo-new"
          MIGS_GLOB="/tmp/*.up.sql"

          pkill -f go-db-demo || true
          sleep 1
          mkdir -p "$APP_DIR"
          mv "$BIN_TMP" "$APP_DIR/go-db-demo"
          chmod +x "$APP_DIR/go-db-demo"

          cat > "$APP_DIR/.env" <<ENVEOF
          SERVER_HOST=0.0.0.0
          SERVER_PORT=8080
          GIN_MODE=release
          DB_HOST=${DB_HOST}
          DB_PORT=5432
          DB_USER=${DB_USER}
          DB_PASSWORD=${DB_PASSWORD}
          DB_NAME=${DB_NAME}
          DB_SSL_MODE=disable
          ENVEOF

          echo "Running migrations (dev DB)..."
          shopt -s nullglob
          for f in ${MIGS_GLOB}; do
            echo "Applying: $f"
            PGPASSWORD="${DB_PASSWORD}" psql -h "${DB_HOST}" -U "${DB_USER}" -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f "$f"
          done
          shopt -u nullglob

          cd "$APP_DIR"
          nohup ./go-db-demo > app.log 2>&1 & echo $! > app.pid
          sleep 2
          curl -fsS http://localhost:8080/health && echo "Dev deploy OK"
          EOF
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}

  # =========================
  # AWS (EC2 + RDS via SSM) — push to main
  # =========================
   deploy_aws:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: us-east-2
      ARTIFACT_BUCKET: go-db-demo-artifacts-906034468384-us-east-2
      INSTANCE_ID: i-00780106ca1ca36e0
      BIN_KEY: releases/${{ github.sha }}/go-db-demo
      MIGS_KEY: releases/${{ github.sha }}/migrations.tar.gz

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: "1.22"

      - name: Build (linux/amd64)
        run: GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="-s -w" -o go-db-demo ./web/cmd

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::906034468384:role/GitHubRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I? (sanity)
        run: aws sts get-caller-identity

      - name: Upload binary + migrations to S3
        run: |
          set -euo pipefail
          aws s3 cp ./go-db-demo "s3://${ARTIFACT_BUCKET}/${BIN_KEY}" --only-show-errors
          tar -czf migrations.tar.gz -C internal/db/migrations . || echo "No migrations dir"
          aws s3 cp ./migrations.tar.gz "s3://${ARTIFACT_BUCKET}/${MIGS_KEY}" --only-show-errors

      - name: SSM - deploy on EC2
        id: ssm
        run: |
          set -euo pipefail
          CMD=$(cat <<'SCRIPT'
          set -euo pipefail
          APP_DIR="/home/ec2-user/app"
          BIN_PATH="/tmp/go-db-demo"
          MIGS_DIR="/tmp/migrations"
          BIN_S3="s3://__BUCKET__/__BIN_KEY__"
          MIGS_S3="s3://__BUCKET__/__MIGS_KEY__"
          if ! command -v psql >/dev/null 2>&1; then
            sudo dnf -y install postgresql jq tar gzip curl || sudo yum -y install postgresql jq tar gzip curl
          fi
          aws s3 cp "${BIN_S3}" "${BIN_PATH}" --only-show-errors
          chmod +x "${BIN_PATH}"
          rm -rf "${MIGS_DIR}"; mkdir -p "${MIGS_DIR}"
          if aws s3 ls "${MIGS_S3}" >/dev/null 2>&1; then
            aws s3 cp "${MIGS_S3}" /tmp/migrations.tar.gz --only-show-errors
            tar -xzf /tmp/migrations.tar.gz -C "${MIGS_DIR}" || true
          fi
          sudo /usr/local/bin/fetch-env.sh /etc/go-db-demo.env /go-db-demo/prod
          export $(grep -v '^#' /etc/go-db-demo.env | xargs)
          pkill -f go-db-demo || true
          sleep 1
          mkdir -p "${APP_DIR}"
          mv "${BIN_PATH}" "${APP_DIR}/go-db-demo"
          chmod +x "${APP_DIR}/go-db-demo"
          shopt -s nullglob
          MIG_FILES=("${MIGS_DIR}"/*.up.sql)
          if [ ${#MIG_FILES[@]} -gt 0 ]; then
            IFS=$'\n' MIG_FILES_SORTED=($(printf "%s\n" "${MIG_FILES[@]}" | sort)); unset IFS
            for f in "${MIG_FILES_SORTED[@]}"; do
              echo "Applying: $(basename "$f")"
              PGPASSWORD="${DB_PASSWORD}" psql -h "${DB_HOST}" -p "${DB_PORT}" -U "${DB_USER}" -d "${DB_NAME}" -v ON_ERROR_STOP=1 -f "$f"
            done
          fi
          shopt -u nullglob
          sudo systemctl daemon-reload
          sudo systemctl enable go-db-demo || true
          sudo systemctl restart go-db-demo
          sleep 2
          curl -fsS http://localhost:8080/health && echo "OK"
          SCRIPT
          )
          CMD_JSON=$(jq -rn --arg bucket "${ARTIFACT_BUCKET}" \
                            --arg binKey "${BIN_KEY}" \
                            --arg migsKey "${MIGS_KEY}" \
                            --arg script "$CMD" \
            '{
              "commands": [
                ($script
                  | gsub("__BUCKET__"; $bucket)
                  | gsub("__BIN_KEY__"; $binKey)
                  | gsub("__MIGS_KEY__"; $migsKey))
              ]
            }')
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy $GITHUB_SHA" \
            --parameters "$CMD_JSON" \
            --region "${AWS_REGION}" \
            --query "Command.CommandId" \
            --output text)
          echo "COMMAND_ID=$COMMAND_ID" >> "$GITHUB_OUTPUT"

      - name: SSM - wait for completion & logs
        run: |
          set -euo pipefail
          COMMAND_ID="${{ steps.ssm.outputs.COMMAND_ID }}"
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${INSTANCE_ID}" \
              --region "${AWS_REGION}" \
              --query "Status" --output text || true)
            if [[ "$STATUS" == "Success" ]]; then break; fi
            if [[ "$STATUS" == "Failed" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" ]]; then
              echo "Status: $STATUS"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" --region "${AWS_REGION}" --output text || true
              exit 1
            fi
            sleep 5
          done
          echo "----- STDOUT -----"
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" --region "${AWS_REGION}" --query "StandardOutputContent" --output text || true
          echo "----- STDERR -----"
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${INSTANCE_ID}" --region "${AWS_REGION}" --query "StandardErrorContent" --output text || true